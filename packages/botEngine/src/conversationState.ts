import { BotState, ConversationState } from '@whatsapp-inventory-bot/schema/src/index';
import { Timestamp } from 'firebase-admin/firestore';

export interface IncomingMessage {
  from: string;
  body: string;
  mediaUrl?: string;
}

export interface BotAction {
  type: 'SEND_MESSAGE' | 'UPDATE_STATE' | 'CREATE_SUPPLIER' | 'CREATE_PRODUCT' | 'UPDATE_INVENTORY' | 'CREATE_ORDER' | 'LOG_DELIVERY';
  payload: Record<string, any>;
}

// Main state machine reducer for the WhatsApp bot
export function conversationStateReducer(
  state: ConversationState,
  message: IncomingMessage
): { newState: ConversationState; actions: BotAction[] } {
  
  const actions: BotAction[] = [];
  let newState: BotState = state.currentState;
  const context = { ...state.context };
  
  // Update the last message timestamp
  const updatedState: ConversationState = {
    ...state,
    lastMessageTimestamp: Timestamp.now(),
  };

  // Main state machine logic
  switch (state.currentState) {
    case 'INIT':
      newState = 'ONBOARDING_NAME';
      actions.push({
        type: 'SEND_MESSAGE',
        payload: {
          body: 'Welcome to the Inventory Bot! Let\'s get you set up. What\'s the name of your restaurant?',
        },
      });
      break;
      
    case 'ONBOARDING_NAME':
      context.restaurantName = message.body.trim();
      newState = 'ONBOARDING_CONTACT';
      actions.push({
        type: 'SEND_MESSAGE',
        payload: {
          body: `Great! What's the name and role of the primary contact person at ${context.restaurantName}? (Format: Name, Role)`,
        },
      });
      break;
      
    case 'ONBOARDING_CONTACT':
      try {
        const [name, role] = message.body.split(',').map(part => part.trim());
        context.primaryContact = { name, role, phone: message.from };
        newState = 'ONBOARDING_PAYMENT';
        actions.push({
          type: 'SEND_MESSAGE',
          payload: {
            body: 'Thanks! Here\'s your payment link to activate the service. Once completed, we\'ll start setting up your suppliers.',
            // In a real implementation, we would generate a unique payment link here
            paymentLink: 'https://payment.example.com/activate/12345',
          },
        });
      } catch (error) {
        actions.push({
          type: 'SEND_MESSAGE',
          payload: {
            body: 'Please provide the name and role in the format: Name, Role',
          },
        });
      }
      break;
      
    // More states would be implemented here...
    
    default:
      actions.push({
        type: 'SEND_MESSAGE',
        payload: {
          body: 'Sorry, I didn\'t understand. Let\'s try again.',
        },
      });
  }

  // Update the state with the new context and state
  updatedState.currentState = newState;
  updatedState.context = context;

  return {
    newState: updatedState,
    actions,
  };
}

// Process the actions generated by the state machine
export async function processActions(actions: BotAction[]): Promise<void> {
  // This would be implemented to handle sending messages, updating Firestore, etc.
  for (const action of actions) {
    switch (action.type) {
      case 'SEND_MESSAGE':
        // Call Twilio API to send the message
        console.log('Sending message:', action.payload.body);
        break;
      
      case 'UPDATE_STATE':
        // Update the conversation state in Firestore
        console.log('Updating state:', action.payload);
        break;
        
      // More action handlers would be implemented here...
    }
  }
}
